{"version":3,"file":"format-string-by-pattern.umd.js","sources":["../src/index.ts"],"sourcesContent":["function getFormattedString(pattern: string, value?: string | number) {\n  if (!value) {\n    return value;\n  }\n\n  const cleanValue = String(value).replace(/[^\\da-zA-Z\\n|]/g, '');\n  const blockSizes = pattern\n    .split(/[^\\da-zA-Z\\n|]/g)\n    .filter(Boolean)\n    .map(b => b.length);\n  const separators = pattern.split(/[\\da-zA-Z\\n|]/g).filter(Boolean);\n  const [firstSeparator] = separators;\n\n  if (pattern.startsWith(firstSeparator)) {\n    const afterReduce = separators.reduce(\n      (acc, cur, index) => {\n        const curBlockSize = blockSizes[index];\n        const beforeSlice = acc.value.slice(0, curBlockSize);\n        const afterSlice = acc.value.slice(curBlockSize);\n        const nextResult = beforeSlice ? acc.result.concat(cur, beforeSlice) : acc.result;\n\n        return {\n          result: nextResult,\n          value: afterSlice,\n        };\n      },\n      {\n        result: '',\n        value: cleanValue,\n      }\n    );\n\n    return afterReduce.result.slice(0, pattern.length);\n  }\n\n  const afterReduce = blockSizes.reduce(\n    (acc, cur, index) => {\n      const curSeparator = separators[index] || '';\n      const replace = `$1${curSeparator}$2`;\n      const curSlice = cur + acc.prevSlice + acc.prevSeparator.length;\n      const curRegex = new RegExp(`(.{${curSlice}})(.)`);\n      const curValue = acc.value.replace(curRegex, replace);\n\n      return {\n        prevSeparator: curSeparator,\n        prevSlice: curSlice,\n        value: curValue,\n      };\n    },\n    {\n      prevSeparator: '',\n      prevSlice: 0,\n      value: cleanValue,\n    }\n  );\n\n  return afterReduce.value.slice(0, pattern.length);\n}\n\nfunction formatStringByPattern(pattern: string): (value?: string | number) => string;\nfunction formatStringByPattern(pattern: string, value: string | number): string;\nfunction formatStringByPattern(pattern: string, value?: string | number) {\n  return value === undefined\n    ? (curriedValue: string | number) => getFormattedString(pattern, curriedValue)\n    : getFormattedString(pattern, value);\n}\n\nexport default formatStringByPattern;\n"],"names":["getFormattedString","pattern","value","cleanValue","String","replace","blockSizes","split","filter","Boolean","map","b","length","separators","firstSeparator","startsWith","reduce","acc","cur","index","curBlockSize","beforeSlice","slice","afterSlice","result","concat","curSeparator","curSlice","prevSlice","prevSeparator","curRegex","RegExp","undefined","curriedValue"],"mappings":"uMAAA,SAASA,EAAmBC,EAAiBC,GAC3C,IAAKA,EACH,OAAOA,EAGT,IAAMC,EAAaC,OAAOF,GAAOG,QAAQ,kBAAmB,IACtDC,EAAaL,EAChBM,MAAM,mBACNC,OAAOC,SACPC,IAAI,SAAAC,GAAK,OAAAA,EAAEC,SACRC,EAAaZ,EAAQM,MAAM,kBAAkBC,OAAOC,SACnDK,OAEP,OAAIb,EAAQc,WAAWD,GACDD,EAAWG,OAC7B,SAACC,EAAKC,EAAKC,GACT,IAAMC,EAAed,EAAWa,GAC1BE,EAAcJ,EAAIf,MAAMoB,MAAM,EAAGF,GACjCG,EAAaN,EAAIf,MAAMoB,MAAMF,GAGnC,MAAO,CACLI,OAHiBH,EAAcJ,EAAIO,OAAOC,OAAOP,EAAKG,GAAeJ,EAAIO,OAIzEtB,MAAOqB,IAGX,CACEC,OAAQ,GACRtB,MAAOC,IAIQqB,OAAOF,MAAM,EAAGrB,EAAQW,QAGzBN,EAAWU,OAC7B,SAACC,EAAKC,EAAKC,GACT,IAAMO,EAAeb,EAAWM,IAAU,GACpCd,EAAU,KAAKqB,OACfC,EAAWT,EAAMD,EAAIW,UAAYX,EAAIY,cAAcjB,OACnDkB,EAAW,IAAIC,OAAO,MAAMJ,WAGlC,MAAO,CACLE,cAAeH,EACfE,UAAWD,EACXzB,MALee,EAAIf,MAAMG,QAAQyB,EAAUzB,KAQ/C,CACEwB,cAAe,GACfD,UAAW,EACX1B,MAAOC,IAIQD,MAAMoB,MAAM,EAAGrB,EAAQW,eAK5C,SAA+BX,EAAiBC,GAC9C,YAAiB8B,IAAV9B,EACH,SAAC+B,GAAkC,OAAAjC,EAAmBC,EAASgC,IAC/DjC,EAAmBC,EAASC"}